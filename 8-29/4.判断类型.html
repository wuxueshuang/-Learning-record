<!DOCTYPE html>
<html lang="zh-cn">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
        <title></title>
		<style>
			
		</style>
		<script>
			/*
				判断类型：
					1.typeOf 
						数组和对象不能分辨出来
					2.constractor
						容易被改写
					3.instanceof
						找原型链上的函数;
					4.Object.prototype.tostring
						几乎完美
			*/

			//--------------------typeof---------------------
			console.log(typeof []);//object
			console.log(typeof {});//object


			//------------------instanceof-------------------
			console.log([] instanceof Array );//true
			console.log([] instanceof Object );//true
			console.log({} instanceof Array );//false
			console.log({} instanceof Object );//true


			//------------------constructor-------------------
			function Info (){

			}

			//如果通过构造函数创建的元素不需要传参，构造函数的括号就可以省略;
			let t1 = new Info;
			console.log(t1);//由构造函数创建出来的对象；
			console.log(Info.prototype.constructor);//构造函数原型上的constractor//指向的是Info这个函数

			let t2 = new Info;
			//console.log(t2.prototype == t1.prototype);//由一个构造函数创建出来的元素的构造函数的原型相同;
			


			// ------------Object.prototype.toString----------
			//把toString中的this指向数组
			console.log(Object.prototype.toString);//function toString() { [native code] }
			console.log(Object.prototype.toString.call([]));//[object Array]//返回的是字符串；
			console.log(Object.prototype.toString.call([]).slice(8,-1)==="Array");//true  返回的这个字符串的开始是固定的，从第8位开始是构造函数，判断这个构造函数是不是Array就可以了;

			console.log({}.toString());//[object Object]字符串表示
			console.log([1,2,3].toString.call([1,2,6]));
		</script>
	</head>

	<body>
		
	</body>
</html>